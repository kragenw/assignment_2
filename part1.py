import GAinspector
import numpy as np
from utils import *
import matplotlib.pyplot as plt


def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    # ret = ''
    # for i in range(length):
    #     ret += str(random.randint(0,1))
    # return ret
    # more verbose

    return "".join(random.choice("01") for _ in range(length))
    
        



def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """
    # population = []
    # for i in range(size):
    #     population.append(randomGenome(length))
    # return population
    # more verbose
    return [randomGenome(length) for _ in range(size)]


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    # counter = 0
    # for b in genome:
    #     if b == "1":
    #         counter += 1
    # return counter
    # more verbose
    
    return sum(1 for b in genome if b =="1")


def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    # total = 0
    # best = -1
    # for genome in population:
    #     score = fitness(genome)
    #     if score > best:
    #         best = score
    #     total += score
    # return total/len(population), best
    # more verbose
    scores = [fitness(genome) for genome in population]
    return sum(scores)/len(scores), max(scores)
        
    



def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    # TODO: find out if you should ever have a crossover point at before or after all bits, effectively stitching the whole thing or doing nothing, I'm doing it so it does
    # lots of time wasted later, this was not the way to do it
    if len(genome1) != len(genome2):
        print("ts aint gon work cuh")
        return False
    crossover_p = random.randint(1,len(genome1) - 1)

    return genome1[:crossover_p] + genome2[crossover_p:], genome2[:crossover_p] + genome1[crossover_p:]


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    genome = list(genome) 
    for i in range(len(genome)):
        if random.uniform(0, 1) <= mutationRate:
            genome[i] = "1" if genome[i] == "0" else "0"
    return "".join(genome)

    

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use weightedChoice, which is available in the Utils File, as a helper function.
    """
    weights = [fitness(genome) for genome in population]
    
    
    
    return weightedChoice(population, weights), weightedChoice(population, weights)
    
    
def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    
    # TODO: make it so it doesn't call evalueateFitness twice per generation
    
    print("Population Size:", populationSize)
    print("Genome Length: 20")
    
    length = 20
    
    generation = makePopulation(populationSize, length)
    
    with open(logFile, "w") as f:
        f.write("")
    
    for i in range(50):
        with open(logFile, "a") as f:
            f.write(f"{i} {round(evaluateFitness(generation)[0], 2)} {evaluateFitness(generation)[1]}\n")
        print(f"Generation {i}: Avg Fitness {round(evaluateFitness(generation)[0], 2)}, Best Fitness {evaluateFitness(generation)[1]}")
        if evaluateFitness(generation)[1] == length:
            print(i)
            return i
        pairs = [(selectPair(generation)) for _ in range(populationSize//2)]
        crossed = [crossover(pair[0], pair[1]) for pair in pairs if random.uniform(0, 1) <= crossoverRate]
        new_generation = []
        for cross in crossed:
            new_generation.append(mutate(cross[0], mutationRate))
            new_generation.append(mutate(cross[1], mutationRate))
        generation = new_generation
        
    return None


def runGA_with_logging(populationSize, crossoverRate, mutationRate, fitnessLog, verbose=True):
    """
    :param populationSize: :param crossoverRate: :param mutationRate: :param fitnessLog: :param logFile: :param verbose: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    
    if verbose:
        print("Population Size:", populationSize)
        print("Genome Length: 20")
    
    length = 20
    
    generation = makePopulation(populationSize, length)
    
    for i in range(50):
        avg_fitness, best_fitness = evaluateFitness(generation)
        fitnessLog.append(avg_fitness)
        if verbose:
            print(f"Generation {i}: Avg Fitness {round(avg_fitness, 5)}, Best Fitness {best_fitness}")
        if best_fitness == length:
            if verbose:
                print(i)
            return i, fitnessLog
        pairs = [(selectPair(generation)) for _ in range(populationSize//2)]
        crossed = [crossover(pair[0], pair[1]) if random.uniform(0, 1) <= crossoverRate else (pair[0], pair[1]) for pair in pairs]
        new_generation = []
        for cross in crossed:
            new_generation.append(mutate(cross[0], mutationRate))
            new_generation.append(mutate(cross[1], mutationRate))
        generation = new_generation

    if verbose:
        print(None)
    return None, fitnessLog
    
      
def runGA_alot(prefix, populationSize=100, crossoverRate=0.7, mutationRate=0.001, runs=50, lines=5):
    """
    Runs the genetic algorithm multiple times and plots the results.

    :param populationSize: Size of the population.
    :param crossoverRate: Probability of crossover.
    :param mutationRate: Probability of mutation.
    :param runs: Number of runs to perform.
    :param lines: Number of runs to plot.
    :return: The average number of generations required to find the string of all ones.
    """
    x = np.arange(runs)
    valid_runs = []
    scores_dict = {}
    total_generations = 0
    not_found_count = 0
    max_generations = -1
    min_generations = float('inf')

    printProgressBar(0, runs, prefix = 'Progress:', suffix = 'Complete', length = 50)

    
    for i in range(runs):
        
        score, averages = runGA_with_logging(populationSize, crossoverRate, mutationRate, [], verbose=False)
        if score is None:
            not_found_count += 1
            continue

        valid_runs.append(i)
        scores_dict[i] = (score, averages)
        max_generations = max(max_generations, score)
        min_generations = min(min_generations, score)
        total_generations += score
        
        printProgressBar(i + 1, runs, prefix = 'Progress:', suffix = 'Complete', length = 50)


    if not_found_count == runs:
        print("No valid runs found.")
        return None


    avg_generations = total_generations / (runs - not_found_count)
    # print(f"Max Generation: {max_generations}, Min Generation: {min_generations}")
    # print(f"Average Generation: {avg_generations}")


    plt.figure()

    random_runs = random.sample(valid_runs, min(lines, len(valid_runs)))
    for i in random_runs:
        score, averages = scores_dict[i]
        plt.plot(range(len(averages)), averages, label=f'Run {i + 1}')
        plt.scatter(score, averages[-1], s=10)
        # plt.text(score + 0.1, averages[-1] + 0.1, f'({score}, {averages[-1]:.2f})', fontsize=12, ha='right', color='red', style='oblique')


    plt.gca().text(
        -0.3, -0.3,                  # (x, y) in axes fraction coords (0–1)
        f'Avg Generation: {avg_generations:.2f}\nMax Generation: {max_generations}\nMin Generation: {min_generations}\nSuccess Rate: {((runs - not_found_count) / runs) * 100:.2f}%',
        transform=plt.gca().transAxes,  # <-- use axes coords, not data coords
        ha='left', va='bottom',
        clip_on=False,
        fontsize=10, color='black'
    )
    
    
    plt.xlabel('Generations')
    plt.ylabel('Average Fitness')
    plt.legend()
    title = f"Population: {populationSize}, Crossover Rate: {crossoverRate}, Mutation Rate: {mutationRate}"
    plt.title(title)

    plt.savefig(f"{prefix}_GA_Pop{populationSize}_Cross{crossoverRate}_Mut{mutationRate}.png", dpi=300, bbox_inches='tight')
    # plt.show()
    
    plt.close()


    return (avg_generations, max_generations, min_generations, (runs - not_found_count) / runs * 100)

def runGA_even_more():
    """
    Runs the genetic algorithm multiple times and writes the results to a single file.

    :return: None
    """
    population_sizes = [20, 50, 100, 200, 500]
    crossover_rates = [0.0, 0.3, 0.7, 1.0]
    mutation_rates = [0.0001, 0.0005, 0.001, 0.005, 0.01]

    with open("GA_results.txt", "w") as result_file:
        result_file.write("Genetic Algorithm Results\n")
        result_file.write("=" * 50 + "\n")

        for pop in population_sizes:
            print("Running Population Size:", pop)
            result_file.write(f"\nRunning Population Size: {pop}\n")
            avg_gen, max_gen, min_gen, success_rate = runGA_alot("p", pop, 0.7, 0.001, 50, 50)
            result_file.write(f"Population Size: {pop}, Avg Generations: {avg_gen:.2f}, Max Generations: {max_gen}, Min Generations: {min_gen}, Success Rate: {success_rate:.2f}%\n")

        for cross in crossover_rates:
            print("Running Crossover Rate:", cross)
            result_file.write(f"\nRunning Crossover Rate: {cross}\n")
            avg_gen, max_gen, min_gen, success_rate = runGA_alot("c", 100, cross, 0.001, 50, 50)
            result_file.write(f"Crossover Rate: {cross}, Avg Generations: {avg_gen:.2f}, Max Generations: {max_gen}, Min Generations: {min_gen}, Success Rate: {success_rate:.2f}%\n")

        for mut in mutation_rates:
            print("Running Mutation Rate:", mut)
            result_file.write(f"\nRunning Mutation Rate: {mut}\n")
            avg_gen, max_gen, min_gen, success_rate = runGA_alot("m", 100, 0.7, mut, 50, 50)
            result_file.write(f"Mutation Rate: {mut}, Avg Generations: {avg_gen:.2f}, Max Generations: {max_gen}, Min Generations: {min_gen}, Success Rate: {success_rate:.2f}%\n")
        


def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = "\r"):
    """
    Call in a loop to create terminal progress bar
    @params:
        iteration   - Required  : current iteration (Int)
        total       - Required  : total iterations (Int)
        prefix      - Optional  : prefix string (Str)
        suffix      - Optional  : suffix string (Str)
        decimals    - Optional  : positive number of decimals in percent complete (Int)
        length      - Optional  : character length of bar (Int)
        fill        - Optional  : bar fill character (Str)
        printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
    """
    percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
    filledLength = int(length * iteration // total)
    bar = fill * filledLength + '-' * (length - filledLength)
    print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
    # Print New Line on Complete
    if iteration == total: 
        print()

if __name__ == '__main__':
    #Testing Code
    # print("Test Suite")
    # GAinspector.inspectFunction(randomGenome)
    # GAinspector.inspectFunction(makePopulation)
    # GAinspector.inspectFunction(fitness)
    # GAinspector.inspectFunction(evaluateFitness)
    # GAinspector.inspectFunction(crossover)
    # GAinspector.inspectFunction(mutate)
    # GAinspector.inspectFunction(selectPair)

    # how to use:
    # runGA(100, 0.7, 0.001, logFile="run1.txt") # runs the GA once with population size 100, crossover rate 0.7, mutation rate 0.001, and logs to run1.txt
    # runGA_alot(100, 0.7, 0.001, 50, 5) # runs the GA 50 times with population size 100, crossover rate 0.7, mutation rate 0.001, and plots 5 of the runs
    runGA_even_more() # runs the GA multiple times with different parameters and logs to GA_results.txt