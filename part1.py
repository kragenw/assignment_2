import GAinspector
import numpy as np
from utils import *
import matplotlib.pyplot as plt


def randomGenome(length):
    """
    :param length:
    :return: string, random binary digit
    """
    # ret = ''
    # for i in range(length):
    #     ret += str(random.randint(0,1))
    # return ret
    # more verbose

    return "".join(random.choice("01") for _ in range(length))
    
        



def makePopulation(size, length):
    """
    :param size - of population:
    :param length - of genome
    :return: list of length size containing genomes of length length
    """
    # population = []
    # for i in range(size):
    #     population.append(randomGenome(length))
    # return population
    # more verbose
    return [randomGenome(length) for _ in range(size)]


def fitness(genome):
    """
    :param genome: 
    :return: the fitness value of a genome
    """
    # counter = 0
    # for b in genome:
    #     if b == "1":
    #         counter += 1
    # return counter
    # more verbose
    
    return sum(1 for b in genome if b =="1")


def evaluateFitness(population):
    """
    :param population: 
    :return: a pair of values: the average fitness of the population as a whole and the fitness of the best individual in the population.
    """
    # total = 0
    # best = -1
    # for genome in population:
    #     score = fitness(genome)
    #     if score > best:
    #         best = score
    #     total += score
    # return total/len(population), best
    # more verbose
    scores = [fitness(genome) for genome in population]
    return sum(scores)/len(scores), max(scores)
        
    



def crossover(genome1, genome2):
    """
    :param genome1:
    :param genome2:
    :return: two new genomes produced by crossing over the given genomes at a random crossover point.
    """
    # TODO: find out if you should ever have a crossover point at before or after all bits, effectively stitching the whole thing or doing nothing, I'm doing it so it does
    # lots of time wasted later, this was not the way to do it
    if len(genome1) != len(genome2):
        print("ts aint gon work cuh")
        return False
    crossover_p = random.randint(1,len(genome1) - 1)

    return genome1[:crossover_p] + genome2[crossover_p:], genome2[:crossover_p] + genome1[crossover_p:]


def mutate(genome, mutationRate):
    """
    :param genome:
    :param mutationRate:
    :return: a new mutated version of the given genome.
    """
    genome = list(genome) 
    for i in range(len(genome)):
        if random.uniform(0, 1) <= mutationRate:
            genome[i] = "1" if genome[i] == "0" else "0"
    return "".join(genome)

    

def selectPair(population):
    """

    :param population:
    :return: two genomes from the given population using fitness-proportionate selection.
    This function should use weightedChoice, which is available in the Utils File, as a helper function.
    """
    weights = [fitness(genome) for genome in population]
    
    
    
    return weightedChoice(population, weights), weightedChoice(population, weights)
    
    
def runGA(populationSize, crossoverRate, mutationRate, logFile=""):
    """

    :param populationSize: :param crossoverRate: :param mutationRate: :param logFile: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    
    # TODO: figure out where crossoverRate comes in, its not used in the crossover function
    
    print("Population Size:", populationSize)
    print("Genome Length: 20")
    
    length = 20
    
    generation = makePopulation(populationSize, length)
    
    with open(logFile, "w") as f:
        f.write("")
    
    for i in range(50):
        with open(logFile, "a") as f:
            f.write(f"{i} {round(evaluateFitness(generation)[0], 2)} {evaluateFitness(generation)[1]}\n")
        print(f"Generation {i}: Avg Fitness {round(evaluateFitness(generation)[0], 2)}, Best Fitness {evaluateFitness(generation)[1]}")
        if evaluateFitness(generation)[1] == length:
            print(i)
            return i
        pairs = [(selectPair(generation)) for _ in range(populationSize//2)]
        crossed = [crossover(pair[0], pair[1]) for pair in pairs if random.uniform(0, 1) <= crossoverRate]
        new_generation = []
        for cross in crossed:
            new_generation.append(mutate(cross[0], mutationRate))
            new_generation.append(mutate(cross[1], mutationRate))
        generation = new_generation
        
    return None


def runGA_with_logging(populationSize, crossoverRate, mutationRate, fitnessLog, verbose=True):
    """
    :param populationSize: :param crossoverRate: :param mutationRate: :param fitnessLog: :param logFile: :param verbose: :return: xt file in which to
    store the data generated by the GA, for plotting purposes. When the GA terminates, this function should return
    the generation at which the string of all ones was found.is the main GA program, which takes the population size,
    crossover rate (pc), and mutation rate (pm) as parameters. The optional logFile parameter is a string specifying
    the name of a te
    """
    
    if verbose:
        print("Population Size:", populationSize)
        print("Genome Length: 20")
    
    length = 20
    
    generation = makePopulation(populationSize, length)
    
    for i in range(50):
        avg_fitness, best_fitness = evaluateFitness(generation)
        fitnessLog.append(avg_fitness)
        if verbose:
            print(f"Generation {i}: Avg Fitness {round(avg_fitness, 5)}, Best Fitness {best_fitness}")
        if best_fitness == length:
            if verbose:
                print(i)
            return i, fitnessLog
        pairs = [(selectPair(generation)) for _ in range(populationSize//2)]
        crossed = [crossover(pair[0], pair[1]) for pair in pairs if random.uniform(0, 1) <= crossoverRate]
        new_generation = []
        for cross in crossed:
            new_generation.append(mutate(cross[0], mutationRate))
            new_generation.append(mutate(cross[1], mutationRate))
        generation = new_generation

    if verbose:
        print(None)
    return None, fitnessLog
    
      
def runGA_alot(populationSize, crossoverRate, mutationRate, runs=50, lines=5):
    """
    Runs the genetic algorithm multiple times and plots the results.

    :param populationSize: Size of the population.
    :param crossoverRate: Probability of crossover.
    :param mutationRate: Probability of mutation.
    :param runs: Number of runs to perform.
    :param lines: Number of runs to plot.
    :return: The average number of generations required to find the string of all ones.
    """
    x = np.arange(runs)
    valid_runs = []
    scores_dict = {}
    total_generations = 0
    not_found_count = 0
    max_generations = -1
    min_generations = float('inf')

    for i in range(runs):
        score, averages = runGA_with_logging(populationSize, crossoverRate, mutationRate, [], verbose=False)
        if score is None:
            not_found_count += 1
            continue

        valid_runs.append(i)
        scores_dict[i] = (score, averages)
        max_generations = max(max_generations, score)
        min_generations = min(min_generations, score)
        total_generations += score

    if not_found_count == runs:
        print("No valid runs found.")
        return None

    avg_generations = total_generations / (runs - not_found_count)
    print(f"Max Generations: {max_generations}, Min Generations: {min_generations}")
    print(f"Average Generations: {avg_generations}")

    random_runs = random.sample(valid_runs, min(lines, len(valid_runs)))
    for i in random_runs:
        score, averages = scores_dict[i]
        plt.plot(range(len(averages)), averages, label=f'Run {i + 1}')
        plt.scatter(score, averages[-1], s=10)
        plt.text(score + 0.1, averages[-1] + 0.1, f'({score}, {averages[-1]:.2f})', fontsize=12, ha='right', color='red', style='oblique')

    plt.xlabel('Generations')
    plt.ylabel('Average Fitness')
    plt.legend()
    plt.show()

    return avg_generations

if __name__ == '__main__':
    #Testing Code
    # print("Test Suite")
    # GAinspector.inspectFunction(randomGenome)
    # GAinspector.inspectFunction(makePopulation)
    # GAinspector.inspectFunction(fitness)
    # GAinspector.inspectFunction(evaluateFitness)
    # GAinspector.inspectFunction(crossover)
    # GAinspector.inspectFunction(mutate)
    # GAinspector.inspectFunction(selectPair)

    # how to use:
    # runGA(populationSize, crossoverRate, mutationRate, logFile="")
    runGA_alot(100, 0, 0.001, 50, 5)

    # runGA(100, 0.7, 0.001, "run1.txt")